# 功能集成说明

## 概述

本文档说明本次实现的三大功能模块的集成和使用方法。

## 一、统一错误码系统

### 后端集成

#### 1. 错误码定义

已扩展 `ResultCode` 枚举类，包含以下类别：

```java
// 业务错误码 (10xxx)
10001 - 密码不正确
10003 - 该用户名已注册
10004 - 请不要输入非法内容
10005 - 用户不存在
10006 - 参数校验失败
10007 - 操作频繁，请稍后再试

// 权限错误码 (20xxx)
20001 - 无权限访问
20002 - 资源不存在

// 数据错误码 (30xxx)
30001 - 数据不存在
30002 - 数据已存在
30003 - 数据保存失败

// 缓存错误码 (40xxx)
40001 - 缓存异常

// 异步处理错误码 (50xxx)
50001 - 异步任务执行失败
```

#### 2. 使用示例

```java
// 在 Service 或 Controller 中使用
if (user == null) {
    throw new GlobalException(ResultCode.USER_NOT_FOUND);
}

// 或者返回错误结果
return ResultUtils.error(ResultCode.PARAM_VALIDATION_ERROR);
```

### 前端集成

#### 1. 管理后台 (Vue 3 + TypeScript)

```typescript
import errorCode from '@/utils/errorCode';

// 使用错误码
console.log(errorCode['10005']); // 输出：用户不存在
```

#### 2. Web客户端 (Vue 2 + JavaScript)

```javascript
import { getErrorMessage } from '@/utils/errorCode';

// 获取错误信息
const message = getErrorMessage(10005);
console.log(message); // 输出：用户不存在
```

#### 3. API 响应处理

```javascript
// 在 axios 拦截器中统一处理
axios.interceptors.response.use(
  response => response,
  error => {
    const code = error.response?.data?.code;
    const message = getErrorMessage(code);
    // 显示错误消息
    Message.error(message);
    return Promise.reject(error);
  }
);
```

## 二、缓存策略

### Redis 缓存配置

系统配置了三种缓存策略：

#### 1. 短期缓存 (5分钟)

适用场景：
- 用户会话数据
- 验证码
- 临时状态

使用方法：
```java
@Cacheable(cacheNames = "shortCache", key = "#userId")
public User getUserSession(Long userId) {
    return userMapper.selectById(userId);
}
```

#### 2. 默认缓存 (10分钟)

适用场景：
- 常规业务数据
- 用户信息
- 好友列表

使用方法：
```java
@Cacheable(key = "#id")
public User getUserById(Long id) {
    return userMapper.selectById(id);
}
```

#### 3. 长期缓存 (1小时)

适用场景：
- 系统配置
- 字典数据
- 静态资源

使用方法：
```java
@Cacheable(cacheNames = "longCache", key = "#configKey")
public String getConfig(String configKey) {
    return configMapper.selectByKey(configKey);
}
```

### 缓存更新

```java
// 更新时清除缓存
@CacheEvict(key = "#user.id")
public void updateUser(User user) {
    userMapper.updateById(user);
}

// 批量清除
@CacheEvict(allEntries = true)
public void clearAllCache() {
    // 清除所有缓存
}
```

## 三、异步处理

### 配置说明

异步任务线程池配置：
- **核心线程数**: 10
- **最大线程数**: 50
- **队列容量**: 1000
- **线程名前缀**: async-task-
- **拒绝策略**: CallerRunsPolicy
- **等待时间**: 60秒

### 使用方法

#### 1. 基本异步方法

```java
@Service
public class NotificationService {
    
    @Async
    public void sendNotification(Long userId, String message) {
        // 异步发送通知
        log.info("发送通知给用户: {}, 消息: {}", userId, message);
    }
}
```

#### 2. 带返回值的异步方法

```java
@Async
public CompletableFuture<Boolean> processDataAsync(Long dataId) {
    try {
        // 处理数据
        processData(dataId);
        return CompletableFuture.completedFuture(true);
    } catch (Exception e) {
        log.error("异步处理失败", e);
        return CompletableFuture.completedFuture(false);
    }
}

// 调用方式
CompletableFuture<Boolean> future = service.processDataAsync(123L);
Boolean result = future.get(); // 阻塞等待结果
```

#### 3. 适用场景

- **消息推送**: 发送通知、短信、邮件
- **数据导出**: 大文件导出
- **日志记录**: 异步写入日志
- **统计计算**: 复杂的数据统计
- **定时任务**: 配合 @Scheduled 使用

## 四、性能监控

### 自动监控

系统自动监控 Controller 和 Service 层的性能：

- **记录指标**: 方法执行时间、请求计数
- **慢方法预警**: 执行时间 > 1秒的方法会记录警告日志
- **日志输出**: 执行时间 > 500ms 的方法会记录信息日志

### 监控 API

#### 1. 获取所有性能指标

```bash
GET /monitor/metrics/all

# 响应
{
  "code": 200,
  "data": {
    "/api/users/list": {
      "endpoint": "/api/users/list",
      "requestCount": 1234,
      "avgResponseTime": 45.6
    }
  }
}
```

#### 2. 健康检查

```bash
GET /monitor/metrics/health

# 响应
{
  "code": 200,
  "data": {
    "status": "UP",
    "timestamp": 1699876543210
  }
}
```

### 前端性能监控

#### 管理后台 (TypeScript)

```typescript
import performanceMonitor from '@/utils/performance';

// 开始监控
performanceMonitor.startMetric('loadUserList');

// 执行操作
await loadUsers();

// 结束监控
const duration = performanceMonitor.endMetric('loadUserList');
console.log('加载用户列表耗时:', duration, 'ms');

// 获取页面性能
const pagePerf = performanceMonitor.getPagePerformance();
console.log('页面加载时间:', pagePerf.loadTime, 'ms');
```

#### Web客户端 (JavaScript)

```javascript
import performanceMonitor from '@/utils/performance';

// 记录API响应时间
performanceMonitor.recordApiMetric('/api/users', 150);

// 获取平均响应时间
const avgTime = performanceMonitor.getAvgApiTime('/api/users');
console.log('平均响应时间:', avgTime, 'ms');
```

## 五、测试框架

### E2E 测试

#### 后端 E2E 测试

```java
public class MyE2ETest extends E2ETestBase {
    
    @Test
    public void testUserFlow() throws Exception {
        // 测试用户注册登录流程
        mockMvc.perform(post("/api/user/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(registerJson))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200));
    }
}
```

#### 前端 E2E 测试

参考文件：
- 管理后台: `im_chat_backstage_ui/tests/e2e/admin.spec.ts`
- Web客户端: `im_chat_web/tests/e2e/chat.spec.js`

安装和运行：
```bash
# 安装 Playwright
npm install --save-dev @playwright/test

# 运行测试
npx playwright test
```

### 负载测试

```java
public class MyLoadTest extends LoadTestBase {
    
    @Test
    public void testApiPerformance() {
        Runnable task = () -> {
            // 测试任务
            callApi();
        };
        
        // 100并发，1000请求
        LoadTestResult result = executeLoadTest(100, 1000, task);
        result.print();
        
        // 断言
        assert result.getAvgResponseTime() < 100;
    }
}
```

## 六、配置说明

### application.yml 配置建议

```yaml
spring:
  # Redis 缓存配置
  redis:
    host: localhost
    port: 6379
    timeout: 10s
  
  # 缓存配置
  cache:
    type: redis
    redis:
      time-to-live: 600000 # 默认10分钟

# 异步任务配置
async:
  executor:
    core-pool-size: 10
    max-pool-size: 50
    queue-capacity: 1000
    thread-name-prefix: async-task-

# 性能监控配置
performance:
  monitor:
    enabled: true
    slow-method-threshold: 1000 # 慢方法阈值(ms)
```

## 七、最佳实践

### 1. 错误码使用

- 使用明确的错误码，避免使用通用错误
- 前后端保持错误码一致
- 重要错误记录日志

### 2. 缓存使用

- 根据数据特点选择合适的缓存策略
- 及时更新或清除缓存
- 防止缓存穿透和雪崩

### 3. 异步处理

- 只对耗时操作使用异步
- 处理好异常情况
- 避免异步方法互相调用导致死锁

### 4. 性能监控

- 定期检查性能指标
- 优化慢方法
- 设置合理的告警阈值

## 八、故障排查

### 问题：缓存不生效

**可能原因**:
1. Redis 连接失败
2. 缓存注解配置错误
3. 方法内部调用导致 AOP 失效

**解决方法**:
- 检查 Redis 连接
- 确认方法是 public
- 使用外部调用而非内部调用

### 问题：异步任务未执行

**可能原因**:
1. 未启用异步配置
2. 方法不是 public
3. 线程池满了

**解决方法**:
- 确认 @EnableAsync 注解存在
- 检查方法可见性
- 查看线程池状态和日志

### 问题：性能监控数据不准确

**可能原因**:
1. 并发更新问题
2. 监控切面配置错误

**解决方法**:
- 使用原子类保证并发安全
- 检查切面配置和包路径

## 九、相关文档

- [E2E测试指南](./E2E测试指南.md)
- [性能优化指南](./性能优化指南.md)
- [API接口文档](./API接口文档.md)
- [部署指南](./部署指南-社交匹配与分销商城.md)

## 十、技术支持

如有问题，请参考：
1. 查看日志文件
2. 检查配置文件
3. 阅读相关文档
4. 提交 Issue
