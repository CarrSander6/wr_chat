# 性能优化指南

## 概述

本文档介绍项目中实施的性能优化策略和最佳实践。

## 缓存策略

### Redis 缓存配置

系统配置了三种缓存策略：

#### 1. 短期缓存（5分钟）
适用于：
- 用户会话数据
- 临时状态信息
- 验证码

使用方式：
```java
@Cacheable(cacheNames = "shortCache", key = "#userId")
public User getUserSession(Long userId) {
    // ...
}
```

#### 2. 默认缓存（10分钟）
适用于：
- 常规业务数据
- 用户信息
- 好友列表

使用方式：
```java
@Cacheable(key = "#id")
public User getUserById(Long id) {
    // ...
}
```

#### 3. 长期缓存（1小时）
适用于：
- 系统配置
- 字典数据
- 静态资源信息

使用方式：
```java
@Cacheable(cacheNames = "longCache", key = "#configKey")
public String getConfig(String configKey) {
    // ...
}
```

### 缓存最佳实践

1. **缓存穿透防护**
   - 启用了 `disableCachingNullValues()` 防止缓存空值
   - 对于可能不存在的数据，使用布隆过滤器

2. **缓存雪崩防护**
   - 设置不同的过期时间
   - 使用随机过期时间偏移

3. **缓存更新策略**
   ```java
   @CacheEvict(key = "#user.id")
   public void updateUser(User user) {
       // 更新用户数据，自动清除缓存
   }
   ```

## 异步处理

### 异步配置

系统配置了专用的异步任务线程池：

- **核心线程数**: 10
- **最大线程数**: 50
- **队列容量**: 1000
- **拒绝策略**: CallerRunsPolicy

### 使用异步任务

```java
@Service
public class NotificationService {
    
    @Async
    public void sendNotification(Long userId, String message) {
        // 异步发送通知
    }
    
    @Async
    public CompletableFuture<Boolean> processData(Long dataId) {
        // 异步处理数据，返回 Future
        return CompletableFuture.completedFuture(true);
    }
}
```

### 适用场景

- 消息推送
- 邮件发送
- 数据导出
- 日志记录
- 统计计算

## 性能监控

### 自动监控

系统自动监控以下层级的性能：

1. **Controller 层**
   - 记录所有 API 请求的响应时间
   - 慢接口预警（>1秒）

2. **Service 层**
   - 记录业务方法执行时间
   - 识别性能瓶颈

### 查看监控数据

#### API 接口

```bash
# 获取所有性能指标
GET /monitor/metrics/all

# 响应示例
{
  "code": 200,
  "data": {
    "/api/users/list": {
      "endpoint": "/api/users/list",
      "requestCount": 1234,
      "avgResponseTime": 45.6
    }
  }
}

# 系统健康检查
GET /monitor/metrics/health
```

#### 日志监控

系统会自动记录慢方法：

```
[性能监控] Controller - 慢方法: UserController.getUserList(), 耗时: 1250ms
[性能监控] Service - 方法: UserService.loadUsers(), 耗时: 800ms
```

## 数据库优化

### 索引优化

确保为常用查询字段创建索引：

```sql
-- 用户表索引
CREATE INDEX idx_username ON user(username);
CREATE INDEX idx_phone ON user(phone);
CREATE INDEX idx_create_time ON user(create_time);

-- 消息表索引
CREATE INDEX idx_from_to ON message(from_id, to_id);
CREATE INDEX idx_create_time ON message(create_time);
```

### 分页查询优化

使用 MyBatis Plus 的分页插件：

```java
Page<User> page = new Page<>(1, 10);
Page<User> result = userMapper.selectPage(page, queryWrapper);
```

### N+1 问题解决

使用一次性加载或批量查询：

```java
// 不推荐：N+1 问题
for (User user : users) {
    List<Friend> friends = friendMapper.selectByUserId(user.getId());
}

// 推荐：批量查询
List<Long> userIds = users.stream()
    .map(User::getId)
    .collect(Collectors.toList());
List<Friend> allFriends = friendMapper.selectByUserIds(userIds);
```

## 前端优化

### 懒加载

```javascript
// 路由懒加载
const UserList = () => import('@/views/user/UserList.vue');

// 组件懒加载
components: {
  HeavyComponent: () => import('@/components/HeavyComponent.vue')
}
```

### 防抖和节流

```javascript
import { debounce, throttle } from 'lodash';

// 防抖：搜索输入
const searchDebounced = debounce(searchUsers, 300);

// 节流：滚动加载
const loadMore = throttle(loadMoreData, 1000);
```

### 图片优化

- 使用合适的图片格式（WebP、JPEG、PNG）
- 图片压缩
- 懒加载图片
- 使用 CDN 加速

## 网络优化

### API 优化

1. **批量接口**
   ```java
   @PostMapping("/batch")
   public Result<List<User>> batchGetUsers(@RequestBody List<Long> userIds) {
       return ResultUtils.success(userService.batchGet(userIds));
   }
   ```

2. **分页优化**
   - 限制单页最大数据量
   - 使用游标分页替代偏移量分页（大数据量）

3. **数据压缩**
   - 启用 GZIP 压缩
   - 减少响应数据大小

### WebSocket 优化

- 使用心跳机制保持连接
- 消息批量发送
- 连接池管理

## 性能测试

### 负载测试

运行负载测试：

```bash
cd im_chat_server/im-platform
mvn test -Dtest=CacheLoadTest
```

### 性能基准

目标性能指标：

| 指标 | 目标值 |
|-----|--------|
| API 平均响应时间 | < 100ms |
| P99 响应时间 | < 500ms |
| 并发支持 | > 1000 QPS |
| 缓存命中率 | > 80% |

## 监控告警

### 关键指标

需要监控的关键指标：

1. **响应时间**: 平均响应时间、P99 响应时间
2. **错误率**: 4xx、5xx 错误率
3. **吞吐量**: QPS、TPS
4. **资源使用**: CPU、内存、磁盘、网络

### 告警规则

建议设置以下告警：

- 平均响应时间 > 500ms
- 错误率 > 5%
- CPU 使用率 > 80%
- 内存使用率 > 85%
- 磁盘使用率 > 90%

## 常见性能问题

### 1. 慢查询

**症状**: 数据库查询耗时长

**解决方案**:
- 添加索引
- 优化查询语句
- 使用缓存
- 分库分表

### 2. 缓存穿透

**症状**: 大量请求查询不存在的数据

**解决方案**:
- 缓存空值（短时间）
- 布隆过滤器
- 参数校验

### 3. 线程池耗尽

**症状**: 异步任务堆积

**解决方案**:
- 增加线程池大小
- 优化任务执行时间
- 使用消息队列

### 4. 内存泄漏

**症状**: 内存持续增长

**解决方案**:
- 检查集合使用
- 关闭资源连接
- 使用弱引用

## 相关文档

- [E2E测试指南](./E2E测试指南.md)
- [API接口文档](./API接口文档.md)
- [部署指南](./部署指南-社交匹配与分销商城.md)
